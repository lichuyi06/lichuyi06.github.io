<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>&#39;原型，原型链&#39;</title>
    <link href="/2025/08/19/%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2025/08/19/%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="new-原型，原型链"><a href="#new-原型，原型链" class="headerlink" title="new, 原型，原型链"></a>new, 原型，原型链</h1><h2 id="1-New的原理"><a href="#1-New的原理" class="headerlink" title="1.New的原理"></a>1.New的原理</h2><p>当我们使用 <code>new</code> 关键字调用一个函数时，JavaScript 会执行以下步骤：</p><blockquote><p>创建一个新的空对象 obj。<br>将 obj.<strong>proto</strong> 指向 Foo.prototype，并绑定this。（实例才能通过原型链访问构造函数上挂载的方法和属性）。<br>执行 执行构造函数代码。<br>返回新对象。</p></blockquote><p><code>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span>; <br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)  <span class="hljs-comment">//Person &#123; name: &#x27;Jack&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>) <span class="hljs-comment">// Jack</span><br>-------------------------------------------------<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span>; <br>   <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)  <span class="hljs-comment">// &#123;age: 18&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>) <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">age</span>) <span class="hljs-comment">// 18</span><br>--------------------------------------------------<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jack&#x27;</span>; <br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;tom&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p)  <span class="hljs-comment">// &#123;name: &#x27;Jack&#x27;&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>) <span class="hljs-comment">// Jack</span><br></code></pre></td></tr></table></figure><h2 id="模拟-new-关键字"><a href="#模拟-new-关键字" class="headerlink" title="模拟 new 关键字"></a>模拟 new 关键字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>;<br>    &#125; <br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123;&#125;; <span class="hljs-comment">// 创建一个空对象，然后改变原型指向，并绑定this</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">call</span>(obj, <span class="hljs-string">&#x27;张三&#x27;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>);  <span class="hljs-comment">// 张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">say</span>());  <span class="hljs-comment">// Hello, my name is 张三</span><br></code></pre></td></tr></table></figure><h2 id="2-原型"><a href="#2-原型" class="headerlink" title="2.原型"></a>2.原型</h2><p>每个函数都有一个 <code>prototype</code> 属性，称之为原型。这个属性的值是个对象，也叫原型对象。作用： 存放一些属性和方法，实例通过原型链可以访问这些方法，从而实现继承和共享行为。这个原型对象上有一个 <code>constructor</code> 属性，指向该函数本身。</p><p><strong>proto</strong> 属性：每个对象都有一个 <code>__proto__</code> 属性，指向创建该对象的构造函数的原型对象（函数本质上也是对象）。</p><h2 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3.原型链"></a>3.原型链</h2><p>这里就先放一张图吧，全面概括了原型链的事<br><img src="/../images/1.png" alt="示例图片"></p><p>重要的点 记住就是:每个函数都是 <code>Function</code> 的实例(instanceof Function 为 true), 函数本身的原型链(<strong>proto</strong>)指向 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的原型链指向 <code>Object.prototype</code>。</p><p>实例如何通过原型链访问方法？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;           <span class="hljs-comment">// 实例属性</span><br>&#125;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">// 原型方法</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);   <span class="hljs-comment">// 创建实例</span><br>f.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// Hello, my name is Alice</span><br><br>--------------------------------------<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">const</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>f.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出: Hello, my name is Alice</span><br><br></code></pre></td></tr></table></figure><blockquote><p>访问 f.sayHello() 的完整流程<br>查找自身属性 -&gt; 沿原型链查找 -&gt; 调用函数 -&gt; 原型链向上查找（如果没找到）</p></blockquote><p> 这里需要注意的是分清楚！！  需要把上面的图写的滚瓜烂熟即可</p><table><thead><tr><th>对象</th><th>原型链上有哪些？</th></tr></thead><tbody><tr><td>Foo (函数对象)</td><td>Foo → Function.prototype → Object.prototype</td></tr><tr><td>f (Foo 的实例)</td><td>f → Foo.prototype → Object.prototype</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;开发中的小知识&#39;</title>
    <link href="/2025/08/19/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/08/19/%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="开发中常用的小知识"><a href="#开发中常用的小知识" class="headerlink" title="开发中常用的小知识"></a>开发中常用的小知识</h1><h2 id="1-依赖相关"><a href="#1-依赖相关" class="headerlink" title="1.依赖相关"></a>1.依赖相关</h2><p>有时经常会遇到之前的代码是正常的，但是未做任何修改，等段时间发现封装的组件出现bug，而官方文档没有这种情况说明，包括issue也为出现。可以考虑清理一下依赖包，我就踩过几次坑。我使用的是pnpm，如果是别的包管理器，替换掉即可。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cos">Remove-Item -Recurse -Force node_modules, pnpm-<span class="hljs-keyword">lock</span>.yaml   <span class="hljs-comment">// </span><br>清理包和锁文件<br>pnpm store prune  <span class="hljs-comment">// 清理缓存，可选</span><br>pnpm install  <br></code></pre></td></tr></table></figure><h2 id="2-git相关"><a href="#2-git相关" class="headerlink" title="2.git相关"></a>2.git相关</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;函数柯里化&#39;</title>
    <link href="/2025/08/19/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2025/08/19/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p><strong>把一个接受多个参数的函数，转化为一系列接受单一参数的函数</strong>，并且返回新函数的技术。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b + c<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curryAdd</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) &#123;<br>      <span class="hljs-keyword">return</span> a + b + c<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curryAdd</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><h2 id="2-好处"><a href="#2-好处" class="headerlink" title="2.好处"></a>2.好处</h2><p>1：参数复用（减少重复传参）</p><p>2：延迟执行（惰性计算）。柯里化的函数不会立即执行，直到最后一个参数传入才会真正计算。</p><p>3：组合函数更方便</p><h2 id="3-经典面试题"><a href="#3-经典面试题" class="headerlink" title="3.经典面试题"></a>3.经典面试题</h2><blockquote><p>实现一个函数，使得满足以下几个要求：</p><p>add(1)(2)(3)(4)&#x2F;&#x2F;输出10</p><p>add(1,2)(3)(4)&#x2F;&#x2F;也输出10</p><p>add(1)(2,3)(4)&#x2F;&#x2F;也输出10</p></blockquote><p>分析： 1 参数不固定 -&gt; … 或者 arguments 来接收。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">...args</span>)&#123;<br><span class="hljs-keyword">let</span> allArgs = []<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="arguments-vs-…args-区别总结"><a href="#arguments-vs-…args-区别总结" class="headerlink" title="arguments vs …args 区别总结"></a>arguments vs …args 区别总结</h3><table><thead><tr><th>特性</th><th><code>arguments</code></th><th><code>...args</code> (剩余参数)</th></tr></thead><tbody><tr><td>类型</td><td>类数组对象（不是真数组）</td><td>真数组</td></tr><tr><td>箭头函数可用？</td><td>❌ 不可用</td><td>✅ 可用</td></tr><tr><td>取名</td><td>固定是 <code>arguments</code></td><td>可以自定义（如 <code>...args</code>、<code>...rest</code>）</td></tr><tr><td>语义</td><td>函数调用时的所有实参</td><td>未被命名的剩余参数</td></tr><tr><td>ES 版本</td><td>ES3 就有</td><td>ES6 引入</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&#39;call,apply,bind函数&#39;</title>
    <link href="/2025/08/19/call-apply-bind%E5%87%BD%E6%95%B0/"/>
    <url>/2025/08/19/call-apply-bind%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="call，apply，bind-函数"><a href="#call，apply，bind-函数" class="headerlink" title="call，apply，bind 函数"></a>call，apply，bind 函数</h1><blockquote><p>以上三个函数都是用来操作js中 this指向的三种方法，核心都是 <strong>改变函数内部的 <code>this</code> 指向</strong>，区别在于调用方式和返回值。</p></blockquote><table><thead><tr><th>方法</th><th>功能</th><th>返回值</th><th>参数形式</th></tr></thead><tbody><tr><td><code>call</code></td><td><strong>立即调用函数</strong>，并指定 <code>this</code></td><td>函数执行结果</td><td>参数以逗号分隔传入</td></tr><tr><td><code>apply</code></td><td><strong>立即调用函数</strong>，并指定 <code>this</code></td><td>函数执行结果</td><td>参数以数组形式传入</td></tr><tr><td><code>bind</code></td><td><strong>返回新函数</strong>，绑定 <code>this</code></td><td>新函数</td><td>参数可部分预置（剩余参数调用时传入）</td></tr></tbody></table><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>先来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">const</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span> &#125;;<br>greet.<span class="hljs-title function_">call</span>(person); <span class="hljs-comment">// Alice</span><br></code></pre></td></tr></table></figure><p>在原本之前这个greet函数的this指向为默认的全局对象（浏览器中是 <code>window</code>，Node 中是 <code>global</code>）</p><p>严格模式下this是<code>undefined</code>。 在使用call调用时 this就会被强制绑定为person对象了，因为是立即执，所以就打印出来 Alice</p><p>官方文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this#%E7%A4%BA%E4%BE%8B">call</a></p><h2 id="手写call函数"><a href="#手写call函数" class="headerlink" title="手写call函数"></a>手写call函数</h2><p>步骤：1.Function原型上挂载自定义方法。2.设置this并调用原函数。 3.接收剩余参数并返回结果。</p><p>这个时候可能有就会有疑问了？为什么一定要在Function原型上挂载自定义方法，(原型,原型链请看这篇文章)。因为这个call方法是要在所以函数都可以使用的方法，每个函数的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深入了解js</title>
    <link href="/2025/08/16/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3js/"/>
    <url>/2025/08/16/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3js/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/08/12/Promise/"/>
    <url>/2025/08/12/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Promise是JavaScript中用于处理异步操作的一种方式。它提供了一种简洁且强大的方法来处理异步代码，避免了方法回调。本文将详细讲解如何从零开始手写一个Promise，帮助您深入理解其工作原理。</p><p>Promise有三种状态：</p><p>Pending（待定）：初始状态，既不是成功也不是失败。<br>Fulfilled（已兑现）：表示异步操作成功完成，并返回了一个成功值。<br>Rejected（已拒绝）：表示异步操作失败，并返回了一个错误原因。</p><pre><code class=" mermaid">flowchart LR    A([开始：创建 Promise]) --&gt; B[状态: Pending&lt;br/&gt;待定]    B -- 异步任务成功 --&gt; C[状态: Fulfilled&lt;br/&gt;已兑现&lt;br/&gt;返回成功值]    B -- 异步任务失败 --&gt; D[状态: Rejected&lt;br/&gt;已拒绝&lt;br/&gt;返回错误原因]</code></pre><p>转换状态如下：</p><p>从Pending状态可以转换成Fulfilled状态。<br>从Pending状态可以转换成Rejected状态。<br>一旦转换到Fulfilled或Rejected状态，Promise的状态就不可再改变。</p><h2 id="2、常用方法"><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h2><p>Promise.resolve()：将给定的值转换为一个 Promise。如果该值本身就是一个 Promise，那么该 Promise将被返回；如果该值是一个 thenable对象，Promise.resolve()将调用其 then() 方法及其两个回调函数；否则，返回的 Promise将会以该值兑现。</p><p>Promise.reject()：返回一个已拒绝（rejected）的 Promise对象，拒绝原因为给定的参数。</p><p>Promise.all()：接受一个 Promise可迭代对象作为输入，并返回一个 Promise。当所有输入的 Promise都被兑现时，返回的 Promise也将被兑现（即使传入的是一个空的可迭代对象），并返回一个包含所有兑现值的数组。如果输入的任何 Promise被拒绝，则返回的 Promise将被拒绝，并带有第一个被拒绝的原因。</p><p>Promise.any()：将一个 Promise可迭代对象作为输入，并返回一个 Promise。当输入的任何一个 Promise兑现时，这个返回的 Promise将会兑现，并返回第一个兑现的值。当所有输入 Promise都被拒绝（包括传递了空的可迭代对象）时，它会以一个包含拒绝原因数组的 AggregateError拒绝。</p><p>Promise.race()：接受一个 Promise可迭代对象作为输入，并返回一个 Promise。这个返回的 Promise会随着第一个 Promise的敲定而敲定。</p><p>Promise.allSettled()：将一个 Promise 可迭代对象作为输入，并返回一个单独的 Promise。当所有输入的 Promise 都已敲定时（包括传入空的可迭代对象时），返回的 Promise 将被兑现，并带有描述每个 Promise 结果的对象数组。</p><h2 id="3-初步流程分析"><a href="#3-初步流程分析" class="headerlink" title="3.初步流程分析"></a>3.初步流程分析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>)&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = (<span class="hljs-params">result</span>) =&gt; &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve执行了--&quot;</span>,result)<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = (<span class="hljs-params">reject</span>) =&gt; &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject执行了--&quot;</span>,reject)<br>        &#125;<br>         <span class="hljs-title function_">executor</span>(_resolve,_reject)<br>      &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行了&#x27;</span>)<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;sucess&#x27;</span>)<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;fall&#x27;</span>)<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 输出结果 </span><br>         执行了<br>promise.<span class="hljs-property">html</span>:<span class="hljs-number">13</span> resolve执行了-- sucess<br>promise.<span class="hljs-property">html</span>:<span class="hljs-number">16</span> reject执行了-- fall<br></code></pre></td></tr></table></figure><p>这部分可能初学者，尤其是面向对象编程思想不强的很难理解。 简述下大概就是MyPromise 构造器里面接收一个函数，然后在构造器内部写了两个 <strong>_resolve</strong>  <strong>_reject</strong> 函数，在构造器内部将这两个方法作为参数传递给传进来的这个匿名函数，因为这个匿名函数( resolve,reject) &#x3D;&gt; {}  这里面的resolve，reject 也是两个函数。此时的 _resolve指向了resolve函数。__reject指向了 reject函。 所以现在就执行了这个匿名函数了，就先打印出来了 console.log(‘执行了’)， 然后继续执行resolve 传入参数’sucess’ 就打印出来了。 就是这样执行。</p><p>再次重点补充：</p><p>传入的匿名函数的参数名 <code>resolve</code> 和 <code>reject</code> 是“形参”，构造器内部的 <code>_resolve</code> 和 <code>_reject</code> 是“实参”。</p><h2 id="2状态及原因"><a href="#2状态及原因" class="headerlink" title="2状态及原因"></a>2状态及原因</h2><p><code>像上图的Promise流程所示， 调用resolve 和 reject其实就是改变 pending为不同的值</code></p><p>核心步骤就是： 添加状态 ——&gt; 添加原因 ———&gt; 调整resolve&#x2F;reject ———-&gt;  状态不可逆 </p><p>所以需要添加一个状态和原因。 这两个都是一个实例属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<br>  state = <span class="hljs-variable constant_">PENDING</span><br>  result = <span class="hljs-literal">undefined</span><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fect</span>)&#123;<br>  <span class="hljs-comment">// 在修改状态的时候 注意状态不可逆，只能是pedding -&gt;</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">_resolve</span> = (<span class="hljs-params">result</span>) =&gt; &#123;<br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">FULFILLED</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = result<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolve执行了--&quot;</span>,result)<br>     &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">_reject</span> = (<span class="hljs-params">reject</span>) =&gt; &#123;<br>     <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">REJECTED</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = reject<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;reject执行了--&quot;</span>,reject)<br>     &#125;<br>    &#125;<br>     <span class="hljs-title function_">fect</span>(_resolve,_reject)<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-then-方法"><a href="#3-then-方法" class="headerlink" title="3.then()方法"></a>3.then()方法</h2><p>核心步骤： </p><pre><code class=" mermaid">flowchart LR    A([添加实例方法]) --&gt; B[参数判断]    B ----&gt; C[执行成功回调]    B ----&gt; D[执行失败回调]</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue3+element-Plus遇见的问题</title>
    <link href="/2025/08/10/vue3%E4%B8%AD%E4%BD%BF%E7%94%A8element-Plus%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2025/08/10/vue3%E4%B8%AD%E4%BD%BF%E7%94%A8element-Plus%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="form表单中常见的问题"><a href="#form表单中常见的问题" class="headerlink" title="form表单中常见的问题"></a>form表单中常见的问题</h1><h2 id="resetField-重置表单"><a href="#resetField-重置表单" class="headerlink" title="resetField 重置表单"></a>resetField 重置表单</h2><p>1 问题复现：假设现在定义了一下表单数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ruleForm = ref&lt;userInfoResult&gt;(&#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">gender</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">employeeNumber</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">departmentId</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">permissionLevel</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">roles</span>: [],<br>  <span class="hljs-attr">permissions</span>: [],<br>&#125;)<br></code></pre></td></tr></table></figure><p>在操作完后使用resetField()方法重置，导致某一项id字段未清除， 往往是因为具体的item项上的prop为绑定，</p><p>请注意，这里有个坑，方法重置的是<strong>初始值</strong>，如果你在onMounted里面设置为表单设置初始值，比如ruleForm.value &#x3D; res， 这时候再使用resetField()数据并不会被重置，因为这时候初始值已经被替换掉了， 应该使用nextick，等DOM更新完毕在设置数据的值，这个时候既可正确清除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(ruleForm.<span class="hljs-property">value</span>, item)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue element-plus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v-model在 vue2 和 vue3 组件上的具体区别</title>
    <link href="/2025/07/22/v-model%E5%9C%A8%20vue2%20%E5%92%8C%20vue3%20%E7%BB%84%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%BA%E5%88%AB/"/>
    <url>/2025/07/22/v-model%E5%9C%A8%20vue2%20%E5%92%8C%20vue3%20%E7%BB%84%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="v-model在-vue2-和-vue3-组件上的具体区别"><a href="#v-model在-vue2-和-vue3-组件上的具体区别" class="headerlink" title="v-model在 vue2 和 vue3 组件上的具体区别"></a>v-model在 vue2 和 vue3 组件上的具体区别</h1><p>无论在 Vue 2 还是 Vue 3 中，<code>v-model</code> 在组件上的使用都依赖于子组件主动触发对应的事件，才能实现父子之间的数据同步。需要遵循单项数据流的原则，子组件是可能去主动修改父组件传递值变化，只能通知父组件去修改，谁的数据谁维护。</p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Test.vue --&gt;<br>&lt;CustomInput v-model=&quot;searchText&quot; /&gt;<br><br>等同于<br>&lt;CustomInput<br>  :value=&quot;searchText&quot;<br>  @input=&quot;newValue =&gt; searchText = newValue&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><template>  <input type="text" :value="value" @input="handleInput($event)" /></template><script>export default {  props: {    value: String  },  methods: {    handleInput (event) {      this.$emit('input', event.target.value)    }  }}</script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- CustomInput.vue --&gt;<br>&lt;template&gt;<br>  &lt;input type=&quot;text&quot; :value=&quot;value&quot; @input=&quot;handleInput($event)&quot; /&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  props: &#123;<br>    value: String<br>  &#125;,<br>  methods: &#123;<br>    handleInput (event) &#123;<br>      this.$emit(&#x27;input&#x27;, event.target.value)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>以上是常规使用中的，但是值得注意的是在组件上 v-model 只可使用一次。vue3中使用也是如此，只不过vue3中默认传递的是modelValue属性，允许多次使用在一个组件中，所有vue3就没有.sync修饰符了</p><ul><li><p>vue3中的v-model</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 父组件中 --&gt;<br>&lt;CustomInput v-model=&quot;searchText&quot; /&gt;<br><br>&lt;!-- 等同于 --&gt;<br>&lt;CustomInput<br>  :modelValue=&quot;searchText&quot;<br>  @update:modelValue=&quot;newValue =&gt; searchText = newValue&quot;<br>/&gt;<br><br><br>&lt;!-- CustomInput.vue --&gt;<br>&lt;template&gt;<br>  &lt;input :value=&quot;modelValue&quot; @input=&quot;onInput&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123; defineProps, defineEmits &#125; from &#x27;vue&#x27;<br>const props = defineProps(&#123;<br>  modelValue: String<br>&#125;)<br>const emit = defineEmits([&#x27;update:modelValue&#x27;])<br>const onInput = (event)=&gt; &#123;<br>  emit(&#x27;update:modelValue&#x27;, event.target.value)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>在实际使用中都不太会设计原生的，所以这些触发事件经常写进某个组件官方提供的值修改变化了的事件里面，可以写在里面 也可以写在外面再去调用这些方法，如果你的项目复杂，并且设计组件二次封装，我是推荐封装为独立的函数再去调用，你可以更好的去输出打印语句，只聚焦去传递的值变化情况。</p><p>实际开发中往往vue3的项目都是采用TS，所以类型定义就需要想清楚，捋清楚到底传出去的可能是个什么值，接收的是什么样的值。</p></li></ul><h2 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h2><p>这个是vue2特有的，是为了<code>v-model</code> 不能同时绑定多个 prop 而设计的语法糖。通过.sync修饰符子组件就可以修改父组件传递下来的值，就不用触发emit事件去通知父组件修改，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 父组件 --&gt;<br>&lt;MyComponent :title=&quot;myTitle&quot; @update:title=&quot;val =&gt; myTitle = val&quot; /&gt;<br>&lt;!-- 等价于 --&gt;<br>&lt;MyComponent :title.sync=&quot;myTitle&quot; /&gt;<br></code></pre></td></tr></table></figure><h2 id="v-model-内置修饰符"><a href="#v-model-内置修饰符" class="headerlink" title="v-model 内置修饰符"></a>v-model 内置修饰符</h2><p>v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy</p><h2 id="v-model-自定义修饰符-vue3"><a href="#v-model-自定义修饰符-vue3" class="headerlink" title="v-model 自定义修饰符(vue3)"></a>v-model 自定义修饰符(vue3)</h2>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于vue3+ts+vite构建的项目 组件自动注入和声明的问题</title>
    <link href="/2025/07/22/%E5%85%B3%E4%BA%8Evue3+ts+vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%20%E7%BB%84%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/22/%E5%85%B3%E4%BA%8Evue3+ts+vite%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%20%E7%BB%84%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%92%8C%E5%A3%B0%E6%98%8E%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="关于vue3-ts-vite构建的项目-组件自动注入和声明的问题"><a href="#关于vue3-ts-vite构建的项目-组件自动注入和声明的问题" class="headerlink" title="关于vue3+ts+vite构建的项目 组件自动注入和声明的问题"></a>关于vue3+ts+vite构建的项目 组件自动注入和声明的问题</h1><p>本文分为两次吧，看看使用插件和自己注册</p><p><strong>在使用自定义组件注册的时候，一定要defineOptions({ name: ‘DateTimePicker’ }) 向外暴露组件的名字</strong>不然无法生效！</p><p>分为三个吧 组件的按需引入，第三方库的API自动导入(如vue的 ref，onMounted，自定义的hooks),样式的按需导入</p><h2 id="组件按需引入"><a href="#组件按需引入" class="headerlink" title="组件按需引入"></a>组件按需引入</h2><p>安装</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">npm i unplugin-vue-components -D  // Vue官方人员开发的一款自动引入插件<br><br>npm i -D unplugin-auto-import    //为 Vite、Webpack、Rollup 和 esbuild 按需自动导入 API，支持 TypeScript<br><br></code></pre></td></tr></table></figure><p>unplugin-auto-import是为了解决在开发中的导入问题，比如经常不清楚相对路径的问题这个插件会在根目录生成一个auto-import.d.ts，这个文件会将所有的插件导入到global中，这样在使用的时候直接就可以使用了。</p><p>1 自动注册组件。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-attr">plugins</span>: [<br>    ........,<br>      <span class="hljs-title class_">Components</span>(&#123;<br>        <span class="hljs-attr">dirs</span>: [<span class="hljs-string">&#x27;src/components&#x27;</span>], <span class="hljs-comment">// 配置需要默认导入的自定义组件文件夹，该文件夹下的所有组件都会自动 import</span><br>        <span class="hljs-attr">dts</span>: <span class="hljs-string">&#x27;src/type/global-components.d.ts&#x27;</span>, <span class="hljs-comment">// 配置声明文件生成位置</span><br>        <span class="hljs-attr">resolvers</span>: [<span class="hljs-title class_">ElementPlusResolver</span>()],<br>        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>],  <span class="hljs-comment">// 组件的有效文件扩展名。</span><br>         <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否搜索子目录</span><br>         <span class="hljs-attr">directoryAsNamespace</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 允许子目录作为组件的命名空间前缀。</span><br>          <span class="hljs-attr">globalNamespaces</span>: [], <span class="hljs-comment">// 忽略命名空间前缀的子目录路径</span><br>          <span class="hljs-attr">directives</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// // 自动导入指令 default: `true` for Vue 3, `false` for Vue 2</span><br>      &#125;),<br>]<br></code></pre></td></tr></table></figure><p>现在就会在对应的文件里面自动生成代码了，一个是组件全局注册的和组件声明的，为什么要声明组件？ 在自定义组件的时候往往对props参数做了类型限制，如果不声明可能在使用该组件的时候缺少TS类型校验。</p><p><img src="https://lichuyi-self.oss-cn-chengdu.aliyuncs.com/QQ20250807-170055.png"></p><p><img src="https://lichuyi-self.oss-cn-chengdu.aliyuncs.com/QQ20250807-170952.png"></p><h2 id="API的按需导入"><a href="#API的按需导入" class="headerlink" title="API的按需导入"></a>API的按需导入</h2><p>配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-comment">// 在defineConfig里面配置</span><br><span class="hljs-title class_">AutoImport</span>(&#123;<br>   ......<br>   <span class="hljs-comment">// resolvers: [ElementPlusResolver()],</span><br>   <span class="hljs-attr">imports</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>, <span class="hljs-string">&#x27;vue-router&#x27;</span>, <span class="hljs-string">&#x27;vue-i18n&#x27;</span>, <span class="hljs-string">&#x27;@vueuse/core&#x27;</span>, <span class="hljs-string">&#x27;pinia&#x27;</span>],<br>   <span class="hljs-attr">dts</span>: <span class="hljs-string">&#x27;./auto-imports.d.ts&#x27;</span>,<br>   <span class="hljs-attr">dirs</span>: [<span class="hljs-string">&#x27;src/stores&#x27;</span>, <span class="hljs-string">&#x27;src/composables&#x27;</span>, <span class="hljs-string">&#x27;src/hooks&#x27;</span>], <span class="hljs-comment">// 导入hooks等需要注入的自定义函数</span><br> &#125;),<br></code></pre></td></tr></table></figure><p>生成的按需导入api</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Generated by &#x27;unplugin-auto-import&#x27;</span><br><span class="hljs-keyword">export</span> &#123;&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">EffectScope</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)[<span class="hljs-string">&#x27;EffectScope&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">acceptHMRUpdate</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;pinia&#x27;</span>)[<span class="hljs-string">&#x27;acceptHMRUpdate&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">asyncComputed</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;asyncComputed&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">autoResetRef</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;autoResetRef&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">computed</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)[<span class="hljs-string">&#x27;computed&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">computedAsync</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;computedAsync&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">computedEager</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;computedEager&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">computedInject</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;computedInject&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">computedWithControl</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;computedWithControl&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">controlledComputed</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;controlledComputed&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">controlledRef</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@vueuse/core&#x27;</span>)[<span class="hljs-string">&#x27;controlledRef&#x27;</span>]<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">createApp</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;vue&#x27;</span>)[<span class="hljs-string">&#x27;createApp&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="vite-plugin-style-import"><a href="#vite-plugin-style-import" class="headerlink" title="vite-plugin-style-import"></a>vite-plugin-style-import</h2><p>这里我没使用，但是用一篇别人的文章来转述吧</p><p>当你使用unplugin-vue-components来引入ui库的时候</p><p>message, notification 等引入样式不生效 安装vite-plugin-style-import即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.js</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> styleImport, &#123;<br>  <span class="hljs-title class_">AndDesignVueResolve</span>,<br>  <span class="hljs-title class_">VantResolve</span>,<br>  <span class="hljs-title class_">ElementPlusResolve</span>,<br>  <span class="hljs-title class_">NutuiResolve</span>,<br>  <span class="hljs-title class_">AntdResolve</span><br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-style-import&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">styleImport</span>(&#123;<br>      <span class="hljs-attr">resolves</span>: [<br>        <span class="hljs-title class_">AndDesignVueResolve</span>(),<br>        <span class="hljs-title class_">VantResolve</span>(),<br>        <span class="hljs-title class_">ElementPlusResolve</span>(),<br>        <span class="hljs-title class_">NutuiResolve</span>(),<br>        <span class="hljs-title class_">AntdResolve</span>()<br>      ],<br>      <span class="hljs-comment">// 自定义规则</span><br>      <span class="hljs-attr">libs</span>: [<br>        &#123;<br>          <span class="hljs-attr">libraryName</span>: <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>,<br>          <span class="hljs-attr">esModule</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">resolveStyle</span>: <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">`ant-design-vue/es/<span class="hljs-subst">$&#123;name&#125;</span>/style/index`</span><br>          &#125;<br>        &#125;<br>      ]<br>    &#125;)<br>  ],<br>  <span class="hljs-comment">// 引用使用less的库要配置一下</span><br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>      <span class="hljs-attr">less</span>: &#123;<br>        <span class="hljs-attr">javascriptEnabled</span>: <span class="hljs-literal">true</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br>作者：藤原托漆<br>链接：<span class="hljs-attr">https</span>:<span class="hljs-comment">//juejin.cn/post/7012446423367024676</span><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure><h2 id="注意点，报错"><a href="#注意点，报错" class="headerlink" title="注意点，报错"></a>注意点，报错</h2><p>还有个坑，如果项目中用了 eslint或者TS 会出现校验错误的，这个时候</p><p>[解决错误]: <a href="https://blog.csdn.net/sayUonly/article/details/123482912">https://blog.csdn.net/sayUonly/article/details/123482912</a>“文章链接”</p><p>我之前是ts出现错误，我加了句：.&#x2F;auto-imports.d.ts到ts的配置文件里面去了，就不会报ts错误。</p><p>同样的加个.&#x2F;components.d.ts 组件的声明文件，否则组件不会有类型提示，路径位置就是之前配置生成的位置，推荐这种全局文件位置放在src外面。整体配置好效果就是如下。有可能还会产生一个问题，就是使用pnpm命令创建的vite项目无法在vscode中获得组件类型提示，这个可以去看官方社区给出的。 还是要跟你的插件版本来看。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-string">&quot;include&quot;</span>: [<span class="hljs-string">&quot;src/**/*.ts&quot;</span>, <span class="hljs-string">&quot;src/**/*.d.ts&quot;</span>,<span class="hljs-string">&quot;./components.d.ts&quot;</span>, <span class="hljs-string">&quot;src/**/*.tsx&quot;</span>, <span class="hljs-string">&quot;src/**/*.vue&quot;</span>,<span class="hljs-string">&quot;./auto-imports.d.ts&quot;</span>],<br></code></pre></td></tr></table></figure><p>然后使用效果就是如下了，会有类型声明。</p><p><img src="https://lichuyi-self.oss-cn-chengdu.aliyuncs.com/fb0e6a5b-249e-4e28-acbf-70081499ee14.png"></p><p>至此也是解决了自动引入自动声明的问题，</p><h2 id="我之前的写法！"><a href="#我之前的写法！" class="headerlink" title="我之前的写法！"></a>我之前的写法！</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">App</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 自动加载 components 下的所有 .vue 文件</span><br><span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;@/components/**/*.vue&#x27;</span>, &#123; <span class="hljs-attr">eager</span>: <span class="hljs-literal">true</span> &#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerGlobalComponents</span>(<span class="hljs-params"><span class="hljs-attr">app</span>: <span class="hljs-title class_">App</span></span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> path <span class="hljs-keyword">in</span> modules) &#123;<br>    <span class="hljs-keyword">const</span> component = (modules[path] <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">default</span><br>    <span class="hljs-keyword">if</span> (component?.<span class="hljs-property">name</span>) &#123;<br>      app.<span class="hljs-title function_">component</span>(component.<span class="hljs-property">name</span>, component)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`全局注册组件: <span class="hljs-subst">$&#123;component.name&#125;</span> (来自: <span class="hljs-subst">$&#123;path&#125;</span>)`</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 在开发环境下，打印所有注册的组件名，方便手动维护类型声明</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">DEV</span>) &#123;<br>    <span class="hljs-keyword">const</span> componentNames = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(modules)<br>      .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">module</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">default</span>?.<span class="hljs-property">name</span>)<br>      .<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;已注册的全局组件列表:&#x27;</span>, componentNames.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>))<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请确保在 src/types/global-components.d.ts 中声明这些组件的类型&#x27;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>声明文件手动生成，也就是写了一个ts文件，每次启动项目时候生成一个声明文件</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-comment">// 扫描组件目录</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">scanComponents</span>(<span class="hljs-params"><span class="hljs-attr">dir</span>: <span class="hljs-built_in">string</span></span>): &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span> &#125;[] &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">components</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span> &#125;[] = []<br>  <span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(dir, &#123; <span class="hljs-attr">withFileTypes</span>: <span class="hljs-literal">true</span> &#125;)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> file <span class="hljs-keyword">of</span> files) &#123;<br>    <span class="hljs-keyword">const</span> fullPath = path.<span class="hljs-title function_">join</span>(dir, file.<span class="hljs-property">name</span>)<br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-title function_">isDirectory</span>()) &#123;<br>      <span class="hljs-comment">// 递归扫描子目录</span><br>      components.<span class="hljs-title function_">push</span>(...<span class="hljs-title function_">scanComponents</span>(fullPath))<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (file.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;index.vue&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 读取组件文件，提取组件名</span><br>      <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(fullPath, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>      <span class="hljs-keyword">const</span> nameMatch = content.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/defineOptions\(\s*&#123;\s*name:\s*[&#x27;&quot;`]([^&#x27;&quot;`]+)[&#x27;&quot;`]/</span>)<br>      <span class="hljs-keyword">if</span> (nameMatch) &#123;<br>        <span class="hljs-keyword">const</span> componentName = nameMatch[<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">const</span> relativePath = path.<span class="hljs-title function_">relative</span>(process.<span class="hljs-title function_">cwd</span>(), fullPath).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)<br>        components.<span class="hljs-title function_">push</span>(&#123;<br>          <span class="hljs-attr">name</span>: componentName,<br>          <span class="hljs-attr">path</span>: <span class="hljs-string">`@/<span class="hljs-subst">$&#123;relativePath.replace(<span class="hljs-string">&#x27;src/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)&#125;</span>`</span>,<br>        &#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> components<br>&#125;<br><span class="hljs-comment">// 生成类型声明文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateTypeDeclaration</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> componentsDir = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;src/components&#x27;</span>)<br>  <span class="hljs-keyword">const</span> components = <span class="hljs-title function_">scanComponents</span>(componentsDir)<br>  <span class="hljs-keyword">let</span> typeContent = <span class="hljs-string">`// Vue 全局组件类型声明 - 自动生成</span><br><span class="hljs-string">// 此文件由 scripts/generate-global-types.js 自动生成，请勿手动修改</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><br>  <span class="hljs-comment">// 生成导入语句</span><br>  components.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">comp</span>) =&gt;</span> &#123;<br>    typeContent += <span class="hljs-string">`import <span class="hljs-subst">$&#123;comp.name&#125;</span> from &#x27;<span class="hljs-subst">$&#123;comp.path&#125;</span>&#x27;\n`</span><br>  &#125;)<br><br>  typeContent += <span class="hljs-string">`</span><br><span class="hljs-string">declare module &#x27;vue&#x27; &#123;</span><br><span class="hljs-string">  export interface GlobalComponents &#123;</span><br><span class="hljs-string">`</span><br>  <span class="hljs-comment">// 生成接口声明</span><br>  components.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">comp</span>) =&gt;</span> &#123;<br>    typeContent += <span class="hljs-string">`    <span class="hljs-subst">$&#123;comp.name&#125;</span>: typeof <span class="hljs-subst">$&#123;comp.name&#125;</span>\n`</span><br>  &#125;)<br>  typeContent += <span class="hljs-string">`  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">export &#123;&#125;</span><br><span class="hljs-string">`</span><br>  <span class="hljs-comment">// 写入文件</span><br>  <span class="hljs-keyword">const</span> outputPath = path.<span class="hljs-title function_">join</span>(process.<span class="hljs-title function_">cwd</span>(), <span class="hljs-string">&#x27;src/types/global-components.d.ts&#x27;</span>)<br>  fs.<span class="hljs-title function_">writeFileSync</span>(outputPath, typeContent)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`已生成全局组件类型声明文件: <span class="hljs-subst">$&#123;outputPath&#125;</span>`</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`发现 <span class="hljs-subst">$&#123;components.length&#125;</span> 个组件:`</span>)<br>  components.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">comp</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`   - <span class="hljs-subst">$&#123;comp.name&#125;</span> (<span class="hljs-subst">$&#123;comp.path&#125;</span>)`</span>)<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// 执行生成</span><br><span class="hljs-title function_">generateTypeDeclaration</span>()<br><span class="hljs-comment">// 生成的代码如下，这个时候使用就用类型声明了</span><br></code></pre></td></tr></table></figure><p><img src="https://lichuyi-self.oss-cn-chengdu.aliyuncs.com/QQ20250808-101649.png"></p><p>使用的时候就是如下的类型提示了</p><p><img src="https://lichuyi-self.oss-cn-chengdu.aliyuncs.com/QQ20250808-101921.png"></p><h2 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h2><p><img src="https://lichuyi-self.oss-cn-chengdu.aliyuncs.com/%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E7%BB%84%E4%BB%B6.png"></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/07/22/hello-world/"/>
    <url>/2025/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
